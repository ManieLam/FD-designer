### 版本1设计结构
```
{
  title: ''
  fields: <array>
  form: <object> {
    attrs: {},
    actions: {},
    buttons: []
  }
  groups
  resources
  template
}
```

### 新结构思路

- 最层级节点是: page， 相当于html中的<body>
- 每一层级都有title: 表示标题
- 最小元素是每一个控件，每个控件有对应不同的属性
- 原fields 修改为 body, 表示内容元素, 流式布局 - 自上而下; 行内/网格/栅格 - 自左向右. 只支持一维数组, 不支持嵌套。那如何表示嵌套呢？使用嵌套/占位，指定该位置另有组件。
- 原form 对象中的attrs, actions, buttons, 提取到外部, 取消form对象, 方便扩展
- template表示布局类型，有几种选项：form/table/page空白页/stepPage流程页
- body: 页面内的子元素, 支持嵌套
- body.tag: 表示元素(字段)使用的组件类型（select/input/table/其他注册供使用的组件name）
- 内部事件: 是否可操作 disableOn<function>, 是否可见 visabledOn<function>
- actions: 行为操作事件, 一般为array, 链式操作, 失败不会阻断继续执行下一个事件, 直到结束
- 联动操作: 字段间联动、表单间联动
``` js
{
  title: '',
  page: [ // 最顶层
    // 表单类型
    { // 以下都是对template指定的设置
      title: '',
      template: 'form' // form\table\alert\body\....
      body: [], // 代表当前template下的所有字段, 数据结构平铺，用parentKey 表示嵌套
      // form: {}, // form 的属性、行为设置; TODO 将form展开
      attrs: {}, // TODO form属性: layout布局格式、是否开启label文本....
      actions: [], // TODO 表单actions提取
      buttons: [], // TODO 表单操作按钮提取
      groups: {}, // TODO 对字段的分组
      resources: {}, // TODO 所有数据源提取
    },
    // 表格类型
    {
      title: '',
      template: 'table',
      // table: {},
      attrs: {}, // 表格属性：是否勾选，行颜色....
      actions: [],
      buttons: [], // TODO 表格操作，能获取到什么数据？
      body: [],
      resources: {}
    },
    // 嵌套，举例: 表单中嵌套一个表格做预览, 修改值触发出侧拉弹窗
    {
      title: '',
      template: 'form',
      attrs: {},
      actions: [],
      groups: {},
      resources: {},
      // 自上而下表示布局结构
      body: [
        {
          tag: 'select',
          name: 'area',
          ...field.attrs, // 不同字段tag类型有不同的属性
          // "执行方"配置触发事件: 当有值改变, 触发 "被执行方"slider, 隐藏/显示
          actions: [
            {
              on: 'change',
              // "被执行方"是name==="slider"的组件
              target: 'slider',
              // event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装
              event: "visabledOn"
            }
            /* change<object>
            input<object>
            foucs<object>
            blur<object> */
          ]
        },
        {
          tag: 'button',
          name: 'button',
          label: '查看预览',
          actions: [
            {
              on: 'click',
              target: 'address' // "被执行方"是name==="address"的表格
              event: 'visabledOn'
            }
          ]
        },
        {
          // 表示嵌套了一个小table做预览
          name: "address", // 依然是这个字段的关键key，用于获取后端数据
          key: "AnsoDataformSelect_1670552077269",
          compTag: "AnsoDataformSelect",
          label: "自定义字段",
          defaultValue: {}，// 默认值配置
          visabled: false,
          tag: "table", // slot表示 空白插槽占位组件，
          ...table属性
        }
        // 表示侧拉弹窗
        {
          name: "slider",
          key: 'xxxx',
          compTag：'el-drawer',
          tag: 'drawer',
          defaultValue: {}, // 侧拉弹窗数据对象
          visabled: false, // 由于侧拉弹窗是默认不可见, 受某些操作被动触发展示, 属于"被执行者", 那么要让它显示, 则还需要在"执行者"方配置actions
        },
      ]
    }
  ]}
    
```

```
    废弃: 用section存储插槽部分
    section: {
      preview: {
        // TODO 如何表示位置? 在某个字段之后? after? 不科学,于是, 重新将body看成类似body,表示页面元素层级关系,就可以得出, 以上
        template: 'table',
        table: {},
        body: [],
      },
      outsideCompont: '外部引用的组件名'
    }
  }

```

``` 
  "执行方"的配置
  {
    name: 'select',
    tag: 'select',
    ...,
    actiions: [
      {
        title: '',
        on: 'change',
        <!-- target: 输入被执行对象name -->
        target: 'slider',
        <!-- event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装 -->
        event: "visabledOn"
      }
    ]
  }
```

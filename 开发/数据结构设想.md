### 版本1设计结构
```
{
  title: ''
  fields: <array>
  form: <object> {
    attrs: {},
    actions: {},
    buttons: []
  }
  groups
  resources
  template
}
```

### 新结构思路

- 最层级节点是: page， 相当于html中的<body>, page由1个或多个canvas组成, 通过template区分类型; canvas可以互相嵌套, 默认一个page存在一个canvas。TODO 创建规则，先创建画布，再拖拽组件
- 每一层级都有title: 表示标题
- 最小元素是每一个控件，每个控件有对应不同的属性
- 原fields 修改为 body, 表示内容元素, 流式布局 - 自上而下; 行内/网格/栅格 - 自左向右. 只支持一维数组, 不支持嵌套。那如何表示嵌套呢？使用嵌套/占位，指定该位置另有组件。
- 原form 对象中的attrs, actions, buttons, 提取到外部, 取消form对象, 方便扩展
- template表示布局类型，有几种选项：form/table/page空白页/stepPage流程页
- body: 页面内的子元素, 支持嵌套
- body.tag: 表示元素(字段)使用的组件类型（select/input/table/其他注册供使用的组件name）

- actions: 行为操作事件, 一般为array, 链式操作, 失败不会阻断继续执行下一个事件, 直到结束
- 联动操作: 字段间联动、表单间联动

``` js
// 以下是描述一个页面存在多画布的数据配置
{
  title: '',
  page: [ // 最顶层
    // 表单类型的画布
    { // 以下都是对template指定的设置
      title: '',
      template: 'form' // form\table\alert\body\....
      body: [], // 代表当前template下的所有字段, 数据结构平铺，用parentKey 表示嵌套
      // form: {}, // form 的属性、行为设置; TODO 将form展开
      attrs: {}, // TODO form属性: layout布局格式、是否开启label文本....
      actions: [], // TODO 表单actions提取
      buttons: [], // TODO 表单操作按钮提取
      groups: {}, // TODO 对字段的分组
      resources: {}, // TODO 所有数据源提取
    },
    // 表格类型的画布
    {
      title: '',
      template: 'table',
      // table: {},
      attrs: {}, // 表格属性：是否勾选，行颜色....
      actions: [],
      buttons: [], // TODO 表格操作，能获取到什么数据？
      body: [],
      resources: {}
    },
    // 嵌套的画布，举例: 表单中嵌套一个表格做预览, 修改值触发出侧拉弹窗
    {
      title: '',
      template: 'form',
      attrs: {},
      actions: [],
      groups: {},
      resources: {},
      // 自上而下表示布局结构
      body: [
        {
          tag: 'select',
          name: 'area',
          ...field.attrs, // 不同字段tag类型有不同的属性
          // "执行方"配置触发事件: 当有值改变, 触发 "被执行方"slider, 隐藏/显示
          actions: [
            {
              on: 'change',
              // "被执行方"是name==="slider"的组件
              target: 'slider',
              // event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装
              event: "visabledOn"
            }
            /* change<object>
            input<object>
            foucs<object>
            blur<object> */
          ]
        },
        {
          tag: 'button',
          name: 'button',
          label: '查看预览',
          actions: [
            {
              on: 'click',
              target: 'address' // "被执行方"是name==="address"的表格
              event: 'visabledOn'
            }
          ]
        },
        {
          // 表示嵌套了一个小table做预览
          name: "address", // 依然是这个字段的关键key，用于获取后端数据
          key: "AnsoDataformSelect_1670552077269",
          compTag: "AnsoDataformSelect",
          label: "自定义字段",
          defaultValue: {}，// 默认值配置
          visabled: false,
          tag: "table", // slot表示 空白插槽占位组件，
          ...table属性
        }
        // 表示侧拉弹窗
        {
          name: "slider",
          key: 'xxxx',
          compTag：'el-drawer',
          tag: 'drawer',
          defaultValue: {}, // 侧拉弹窗数据对象
          visabled: false, // 由于侧拉弹窗是默认不可见, 受某些操作被动触发展示, 属于"被执行者", 那么要让它显示, 则还需要在"执行者"方配置actions
        },
      ]
    }
  ]}
    
```

```
    废弃: 用section存储插槽部分
    section: {
      preview: {
        // TODO 如何表示位置? 在某个字段之后? after? 不科学,于是, 重新将body看成类似body,表示页面元素层级关系,就可以得出, 以上
        template: 'table',
        table: {},
        body: [],
      },
      outsideCompont: '外部引用的组件名'
    }
  }

```

``` 
  "执行方"的配置
  {
    name: 'select',
    tag: 'select',
    ...,
    actiions: [
      {
        title: '',
        on: 'change',
        <!-- target: 输入被执行对象name -->
        target: 'slider',
        <!-- event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装（选项改变、数值改变、校验规则改变....(属性改变) /默认值改变/发起请求） -->
        event: "visabledOn"
      }
    ]
  }
```

```
 当"被执行方"存在多个时，配置多个对象
 {
    name: 'select',
    tag: 'select',
    ...,
    actiions: [
      {
        title: '',
        on: 'change',
        <!-- target: 输入被执行对象name -->
        target: 'slider',
        <!-- event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装 -->
        event: "visabledOn"
      },
      {
        title: '',
        on: 'change',
        <!-- target: 输入被执行对象name -->
        target: 'field1',
        <!-- event: 选择内部封装的操作事件: 隐藏/显示(visabledOn), 停用/启用(disabledOn)... 其他待封装 -->
        event: "visabledOn"
      }
    ]
  }
```

```
  <!-- 触发“被动方”，选项改变、数值改变、校验规则改变....(属性改变) / 默认值改变 / 发起请求 -->
  actions: [
    {
      // 选项改变
      on: 'change',
      target: 'fieldName',
      event: 'optionChangeEvent' // 根据field配置的option情况：重新发起api请求 / 重新赋值
    },
    {
      // 数值改变
      on: 'change',
      target: 'fieldName',
      event: 'valueChangeEvent' // 根据field配置的默认值调整 / 自定义运算？
    },
    {
      // 校验规则改变
      event: 'ruleChangeEvent' // 替换？在原rules中修改？
    },
    {
      // 发起请求
      event: 'apiRequireEvent'
    },
    {
      // 清空数值
    },
    {
      // 
    }
  ]
```

```
 <!-- 弹窗选中之后，数值回填 -->
```

``` js
// 转译部分
// 当遇到配置信息为：
select: {
  actions: [
    {
      on: 'change',
      target: ['A', 'B', 'c'],
      event: 'visableEvent'
    }
  ]
}
// 表示需要对每个字段属性做监听
/**
 * @param datas <>表单默认数据集合 + 表单录入信息
 * @param value <any>当前字段输入的值
 * @param fields <Array>表单内所有配置的字段
 * @param field 当前字段配置
 * @return true: 显示；false：隐藏
 * 当....时候显示target，当....时候隐藏target
*/
// 一般写显示/隐藏， 满足条件？true：false
// 条件：
visabledEvent: (datas, value, fields, field) => {
  return datas.area !== '' ? fields.find(a)
}
```

### 联动操作思路

```
- 操作动作: 
  - 通用动作
  
    - 是否可操作 disableOn<function>
    - 是否可见 visabledOn<function>
  - 组件动作
  - 广播动作
  - 自定义动作

  | 动作类型 | 动作名称 |
  | -- | -- |
  | 组件动作 | |
  | 页面动作 | |
  | 弹窗动作 | |
```

[参考](https://baidu.gitee.io/aisuda-docs/%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E5%99%A8/%E9%80%9A%E7%94%A8%E6%9C%BA%E5%88%B6/%E4%BA%8B%E4%BB%B6%E4%BA%A4%E4%BA%92/%E7%AE%80%E4%BB%8B)
条件参数A：
  1. 表单数值（表单默认数据集+表单录入信息）
  2. 当前字段最新数值(指：当前操作的控件数值)
  3. 表单内所有配置的字段
  4. 当前字段配置
  5. 地址参数
  6. 本地缓存参数
  7. 预设条件：今日时间、日期、周数、年份等
  8. 组合条件（通过n个条件参数And/Or形成组合；条件间关系：And、Or）
运算符B：==、!=、>、>=、<、<=、in、notNull
条件间关系C：And（all）、Or（any）
结果判定(执行内容)D：
  1. 布尔值：true/false
  2. 固定值：手工输入
  3. 选值：${数据源}.${属性名}
  4. 数据集合 
   
------

| 配置的组件 | 组件行为 |
| --- | --- |
| n | 数值变化/失焦/聚焦.... |

- 规则设计器
  
| 条件（当....) A  | 运算符 （符合...）B | 阀值 |
| --- | --- | --- |
| 当前字段最新数值(指：当前操作的控件数值) | !== | null/''/undefined |
| 当前字段最新数值(指：当前操作的控件数值) | in | 数据类型 |
| 当前字段最新数值(指：当前操作的控件数值) | === | “机械”对应的value/某个开票类型的value/某个选项的value |
| 当前字段最新数值(指：当前操作的控件数值) | in | 数据类型 |

- 行为操作执行器
<!-- 将...[事件]目标 -->
| 示例 | 执行内容（将...） D | 执行事件 | 目标的键名 |
| --- | --- | --- | --- |
| 根据所选证件类型，改变证件号校验规则 | 某个数值对应的新校验规则/某个数值对应的单位 | 修改属性 | 属性.校验规则/单位 |
| 省市区联动选择（选项过滤器） | 过滤后的options内容 | 改变选项 | 字段键名 |
| 表具类型选择”机械“，清空远传采集编号 | null | 赋值 | 远传采集编号Key |
| 将选中的表具填充到表单多个值 | D4 数据集合 | 赋值 | 表单组件键名.${默认数据集合} + 配置表单组件中的字段为指定的数据键名 |
| 输入用水人口，根据配置计算附加人口并显示 | - | 发起异步请求 | 不需要填；在异步请求中配置数据处理的后置操作中赋值
| 根据内容发起工单 抄表时选择”表坏“，自动显示表具维修工单发起界面（弹窗/侧拉/其他形式）| 表单信息 | 显示+赋值  | 相应形式的组件 |


